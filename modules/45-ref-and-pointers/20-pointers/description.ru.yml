---
name: Указатели
theory: |
  Теперь, когда в наши инструменты добавлены оператор адреса и оператор косвенного обращения, мы можем поговорить об указателях. Указатель – это переменная, которая в качестве значения хранит адрес памяти.

  ## Объявление указателя

  Переменные-указатели объявляются так же, как обычные переменные, только со звездочкой между типом данных и именем переменной. Обратите внимание, что эта звездочка не является косвенным обращением. Это часть синтаксиса объявления указателя.

  ```cpp
  int *i_ptr {};    // указатель на значение типа int
  double *d_ptr {}; // указатель на значение типа double
 
  int* i_ptr2 {};  // тоже допустимый синтаксис
  int * iPtr3{}; // тоже допустимый синтаксис (но не делайте так, это похоже на умножение)
  ```

  Синтаксически C++ принимает звездочку рядом с типом данных, рядом с именем переменной или даже в середине.

  При объявлении переменной-указателя ставьте звездочку рядом с типом, чтобы его было легче отличить от косвенного обращения.

  Как и обычные переменные, указатели не инициализируются при объявлении. Если они не инициализированы значением, они будут содержать мусор.

  Одно замечание по номенклатуре указателей: «указатель X» (где X – какой-либо тип) – это обычно используемое сокращение для «указателя на X». Поэтому, когда мы говорим «указатель int», мы на самом деле имеем в виду «указатель на значение типа int».

  ## Присвоение значения указателю

  Поскольку указатели содержат только адреса, когда мы присваиваем значение указателю, это значение должно быть адресом. Одна из самых распространенных вещей, которые делают с указателями, – это хранение в них адреса другой переменной.

  Чтобы получить адрес переменной, мы используем оператор адреса:

  ```cpp
  #include <iostream>

  int main() {
    int num { 5 };
    int* ptr { &num }; // инициализируем ptr адресом переменной num

    std::cout << &num << '\n';  // выводим адрес переменной num
    std::cout << ptr << '\n'; // выводим адрес, который хранится в ptr
 
    return 0;
  }
  ```

  Эта программа создает следующий вывод:

  <pre class='hexlet-basics-output'>
    0x7ffc5d336fc8
    0x7ffc5d336fc8
  </pre>

  ptr содержит адрес значения переменной, поэтому мы говорим, что ptr «указывает на» `num`.

  Тип указателя должен соответствовать типу переменной, на которую он указывает:

  ```cpp
  int i_value { 5 };
  double d_value { 7.0 };
 
  int* i_ptr { &iValue };    // ok
  double* d_ptr { &dValue }; // ok
  i_ptr = &d_value; // ошибка
  ```

  Типа double не может указывать на адрес переменной типа int. Обратите внимание, что следующее также некорректно:

  ```cpp
  int* ptr { 5 };
  ```
  Это связано с тем, что указатели могут содержать только адреса, а целочисленный литерал 5 не имеет адреса памяти. Если вы попробуете это сделать, компилятор сообщит вам, что он не может преобразовать `int` в указатель `int`.

  ## Оператор адреса возвращает указатель.

  Стоит отметить, что оператор адреса (&) не возвращает адрес своего операнда в виде литерала. Вместо этого он возвращает указатель, содержащий адрес операнда, тип которого является производным от аргумента (например, взятие адреса значения `int` вернет адрес в указателе `int`).

  Мы можем увидеть это в следующем примере:

  ```cpp
  #include <iostream>
  #include <typeinfo>
 
  int main() {
    int num { 4 };
    std::cout << typeid(&x).name() << std::endl;

    return 0;
  }
  ```

  В Visual Studio этот код напечатал:

   <pre class='hexlet-basics-output'>
    int *
  </pre>

  При компиляции gcc вместо этого выводит "pi" («pointer to int», указатель на int).

  ## Косвенное обращение через указатели

  Когда у нас есть переменная-указатель, указывающая на что-то, другая распространенная вещь, которую мы делаем с ней, – это косвенное обращение через указатель для получения значения того, на что он указывает. Косвенное обращение через указатель вычисляет содержимое адреса, на который он указывает.

  ```cpp
  int value { 5 };
  std::cout << &value << std::endl; // выводит адрес value
  std::cout << value << std::endl;  // выводит содержимое value
  
  int* ptr { &value }; // ptr указывает на value
  std::cout << ptr << std::endl;   // выводит адрес, содержащийся в ptr, который равен &value
  std::cout << *ptr << std::endl;  // косвенное обращение через ptr (получаем значение, на которое указывает ptr)
  ```

  Эта программа создает следующий вывод:

  <pre class='hexlet-basics-output'>
    0x7ffcc0b6824c
    5
    0x7ffcc0b6824c
    5
  </pre>

  Вот почему указатели должны иметь тип. Без типа, при косвенном обращении через указатель, указатель не знал бы, как интерпретировать содержимое, на которое он указывает. По этой же причине тип указателя и тип переменной, адрес которой ему присваивается, должны совпадать. Если бы это было не так, косвенное обращение через указатель неверно интерпретировало бы биты как другой тип.

  После присваивания значению указателя можно присвоить другое значение:

  ```cpp
  int value1{ 5 };
  int value2{ 7 };
  
  int* ptr{};
  
  ptr = &value1;     // ptr указывает на value1
  std::cout << *ptr; // выводит 5
  
  ptr = &value2;     // ptr теперь указывает на value2
  std::cout << *ptr; // выводит 7
  ```

  Когда адрес переменной `value` присваивается указателю `ptr`, верно следующее:

  - `ptr` равен `&value`
  - `*ptr` обрабатывается так же, как value

  Поскольку `*ptr` обрабатывается так же, как `value`, вы можете присваивать ему значения, как если бы это была переменная `value` Следующая программа напечатает 7:

  ```cpp
  int value { 5 };
  int* ptr  { &value }; // ptr указывает на value
 
  *ptr = 7; // *ptr - это то же, что и value, которому присвоено 7
  std::cout << value << std::endl; // выводит 7
  ```

  ## Предупреждение о косвенном обращении через недействительные указатели

  Указатели в C++ по своей сути небезопасны, и неправильное использование указателей – один из лучших способов вывести ваше приложение из строя.

  Во время косвенного обращения через указатель приложение пытается перейти в ячейку памяти, которая хранится в указателе, и получить содержимое памяти. В целях безопасности современные операционные системы используют приложения-песочницы, чтобы предотвратить их неправильное взаимодействие с другими приложениями и защитить стабильность самой операционной системы.

  Если приложение пытается получить доступ к области памяти, не выделенной ему операционной системой, операционная система может завершить работу приложения.

  Следующая программа иллюстрирует это и, вероятнее всего упадет с ошибкой:

  ```cpp
  #include <iostream>

  // Мы рассмотрим & позже. Пока не беспокойтесь об этом, мы используем его только для того,
  // чтобы заставить компилятор думать, что p имеет значение. 
  void foo(int*&p) {
    // p - ссылка на указатель. Мы рассмотрим ссылки (и ссылки на указатели) позже в этой главе.
    // Мы используем ее, чтобы заставить компилятор думать, что p мог быть изменен,
    // поэтому он не будет жаловаться на то, что p неинициализирован.
  }
 
  int main() {
    int* p; // Создаем неинициализированный указатель (указывающий на мусор)
    foo(p); // Обманываем компилятор, заставляя его думать, что мы собираемся присвоить указателю допустимое значение

    std::cout << *p << std::endl; // Косвенное обращение через указатель на мусор
 
    return 0;
  }
  ```

  ## Размер указателей

  Размер указателя зависит от архитектуры, для которой скомпилирован исполняемый файл – 32-битный исполняемый файл использует 32-битные адреса памяти – следовательно, указатель на 32-битной машине занимает 32 бита (4 байта). С 64-битным исполняемым файлом указатель будет 64-битным (8 байтов). Обратите внимание, что это верно независимо от размера объекта, на который он указывает:

  ```cpp
  char* ch_ptr {}; // char равен 1 байту
  int* i_ptr {}; // int обычно равен 4 байтам
  
  std::cout << sizeof(ch_ptr) << std::endl; // выводит  4
  std::cout << sizeof(i_ptr) << std::endl; // выводит 4
  ```

  Как видите, размер указателя всегда один и тот же. Это связано с тем, что указатель – это просто адрес памяти, а количество битов, необходимых для доступа к адресу памяти на данной машине, всегда постоянно.

  Что хорошего в указателях:

   - Массивы реализованы с помощью указателей. Указатели могут использоваться для итерации по массиву

   - указатели в C++ это единственный способ динамического выделения памяти

   - их можно использовать для передачи функции в качестве параметра другой функци

   - их можно использовать для достижения полиморфизма при работе с наследованием

   - их можно использовать, чтобы иметь указатель на одну структуру/класс в другой структуре/классе, чтобы сформировать цепочку. Это полезно в некоторых более сложных структурах данных, таких как связанные списки и деревья

  Подведем итог. В этом уроке мы познакомились с указателями, узнали как их объявлять, как присваивать им значения и как безопасно работать с ними.

instructions: |
  Поменяйте значения переменный `first_num` и `second_num` местами. Попробуйте это сделать с помощью уже созданных указателей.

tips:
  - |
    [Указатели](https://learn.microsoft.com/ru-ru/cpp/cpp/pointers-cpp?view=msvc-170)
